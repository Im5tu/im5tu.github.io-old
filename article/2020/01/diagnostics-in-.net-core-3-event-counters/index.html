<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=author content="Stuart Blackler"><meta name=description content="Recently, I&amp;rsquo;ve been playing with the new diagnostic improvements in .Net Core 3. Traditionally, I&amp;rsquo;ve always used the great AppMetrics package to capture the metrics from our applications and send scrape them with a Prometheus &amp;amp; Grafana setup. Whilst reading about the improvements, I wondered whether or not it would be possible to push metrics to Prometheus."><meta name=keywords content=",aspnetcore,dotnet,diagnostics"><meta name=robots content="noodp"><meta name=theme-color content><link rel=canonical href=https://im5tu.io/article/2020/01/diagnostics-in-.net-core-3-event-counters/><title>Diagnostics in .Net Core 3: Event Counters :: Stuart Blackler's Blog</title><link href=https://cdnjs.cloudflare.com/ajax/libs/flag-icon-css/3.5.0/css/flag-icon.min.css rel=stylesheet type=text/css><link rel=stylesheet href=/main.393856bf2c430bb6c01d7af07c6fe966e7cce8073435cfbbc46e590bab7405ef.css><meta itemprop=name content="Diagnostics in .Net Core 3: Event Counters"><meta itemprop=description content="A look into the EventCounters API in .Net Core 3"><meta itemprop=datePublished content="2020-01-05T14:00:00+00:00"><meta itemprop=dateModified content="2020-01-05T14:00:00+00:00"><meta itemprop=wordCount content="2901"><meta itemprop=keywords content="aspnetcore,dotnet,diagnostics,"><meta name=twitter:card content="summary"><meta name=twitter:title content="Diagnostics in .Net Core 3: Event Counters"><meta name=twitter:description content="A look into the EventCounters API in .Net Core 3"><meta property="og:title" content="Diagnostics in .Net Core 3: Event Counters"><meta property="og:description" content="A look into the EventCounters API in .Net Core 3"><meta property="og:type" content="article"><meta property="og:url" content="https://im5tu.io/article/2020/01/diagnostics-in-.net-core-3-event-counters/"><meta property="article:published_time" content="2020-01-05T14:00:00+00:00"><meta property="article:modified_time" content="2020-01-05T14:00:00+00:00"><meta property="article:section" content="aspnetcore"><meta property="article:section" content="dotnet"><meta property="article:section" content="diagnostics"><meta property="article:published_time" content="2020-01-05 14:00:00 +0000 UTC"><link rel=alternate type=application/rss+xml href=https://im5tu.io/article/2020/01/diagnostics-in-.net-core-3-event-counters/index.xml title="Stuart Blackler's Blog"><meta property="og:image" content="https://im5tu.io/img/profile.jpg"><meta property="og:site_name" content="Stuart Blackler's Blog"><link rel=alternate type=application/rss+xml href=/index.xml title="Stuart Blackler's Blog"><link rel=preconnect href=https://api.github.com><link rel=preconnect href=https://partner.googleadservices.com><link rel=preconnect href=https://tpc.googlesyndication.com><link rel=preconnect href=https://www.googletagservices.com><link rel=preconnect href=https://googleads.g.doubleclick.net><link rel=preconnect href=https://pagead2.googlesyndication.com><link rel=preload href=/fonts/Inter-UI-Bold.woff2><link rel=preload href=/fonts/Inter-UI-Regular.woff2><style>.post{max-width:1200px}.header__inner{width:100%;max-width:1160px}.copy-code-button{float:right;display:block;padding:8px 12px;font-size:.9em;background-color:#e2e2e2;border-left:1px solid #e2e2e2;border-bottom:1px solid #e2e2e2;border-radius:0;border-bottom-left-radius:10px;transition:all 250ms ease;margin:-18px;opacity:0}.copy-code-button:hover{cursor:pointer;opacity:.7;border-style:solid}.copy-code-button:focus{background-color:#e2e2e2;outline:0;border-style:solid}.copy-code-button:active{background-color:#e2e2e2;opacity:.5;border-style:solid}pre:hover .copy-code-button{opacity:1}.copy-code-button~pre{position:relative}table{width:100%;border-collapse:collapse}table th{background-color:#cecece;color:#222}table tr{margin:0;padding:0}table tr:first-child{border-left:1px solid #acacac;border-top:1px solid #acacac;border-right:1px solid #acacac}table tr td:first-child{border-left:1px solid #acacac}table tr td:last-child{border-right:1px solid #acacac}table td,table th{padding:.5em;border-bottom:1px solid #acacac;margin:0}h2 a:link,h2 a:visited,h3 a:link,h3 a:visited,h4 a:link,h4 a:visited,h5 a:link,h5 a:visited{text-decoration:none}h2 a:hover,h3 a:hover,h4 a:hover,h5 a:hover{text-decoration:underline}@media print{.copy-code-button{display:none}}@media(prefers-color-scheme:dark){.copy-code-button{background-color:#969696;color:#323232}}</style><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create','UA-88036425-1','auto');ga('send','pageview');</script><script data-ad-client=ca-pub-8597760177900459 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body class=dark-theme><div class=container><header class=header><span class=header__inner><a href=/ style=text-decoration:none><div class=logo><span class=logo__mark>></span>
<span class=logo__text>im5tu.io</span>
<span class=logo__cursor></span></div></a><span class=header__right><nav class=menu><ul class=menu__inner><li><a href=https://im5tu.io/article/>Articles</a></li><li><a href=https://im5tu.io/article/index.xml>RSS Feed</a></li><li><a href=https://bit.ly/im5tu-tw>Twitter</a></li><li><a href=https://bit.ly/im5tu-yt>YouTube</a></li></ul></nav><span class=menu-trigger><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg></span><span class="theme-toggle unselectable"><svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M22 41C32.4934 41 41 32.4934 41 22 41 11.5066 32.4934 3 22 3 11.5066 3 3 11.5066 3 22s8.5066 19 19 19zM7 22C7 13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22z"/></svg></span></span></span></header><div class=content><main class=post><div class=post-info><p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-clock"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>14 minutes</p></div><article><h1 class=post-title><a href=https://im5tu.io/article/2020/01/diagnostics-in-.net-core-3-event-counters/>Diagnostics in .Net Core 3: Event Counters</a></h1><div class=post-content><section class="series series-header"><p><i>This article is part of the <a href=#series>Diagnostics in .Net Core 3</a> series. You are reading part 1 of 5.</i></p></section><p>Recently, I&rsquo;ve been playing with the new <a href=https://devblogs.microsoft.com/dotnet/introducing-diagnostics-improvements-in-net-core-3-0/>diagnostic improvements in .Net Core 3</a>. Traditionally, I&rsquo;ve always used the great <a href=https://github.com/AppMetrics/AppMetrics>AppMetrics</a> package to capture the metrics from our applications and send scrape them with a <a href=https://github.com/prometheus/prometheus>Prometheus</a> & <a href=https://github.com/grafana/grafana>Grafana</a> setup. Whilst reading about the improvements, I wondered whether or not it would be possible to push metrics to <a href=https://github.com/prometheus/prometheus>Prometheus</a>.</p><p>Ultimately, I decided that pushing to <a href=https://github.com/prometheus/prometheus>Prometheus</a> wasn&rsquo;t ideal for my use case. However, I have successfully used the approach described in the rest of the article to push the metrics to another platform, using a new .Net API - EventCounters.</p><p>EventCounters are the .NET Core replacement for Windows performance counters, which are now cross platform. EventCounters are based on the EventPipe that was originally introduced in .Net Core 2.2, but .Net Core 3.0+ adds a lot of additional functionality that we can use going forward to create cross platform monitoring tools for our applications including:</p><ul><li><code>dotnet-dump</code> takes memory snapshot and allow analysis based on most SOS commands;</li><li><code>dotnet-trace</code> collects events emitted by the Core CLR and generate trace file to be analyzed with PerfView;</li><li><code>dotnet-counters</code> collects the metrics corresponding to some performance counters that used to be exposed by the .NET Framework.</li></ul><p><em>Please note that this article is correct at the time of writing based on the <a href=https://source.dot.net>sources</a> available. I do describe some of the internal workings of the API, which may change overtime.</em></p><h2 id=application-flow>Application Flow</h2><p>In order to use the new EventCounters API, you first need to create an inherited class that derives from EventSource because every type of counter needs to be registered against an EventSource. Let&rsquo;s start off with the simplist possible EventSource that records metrics dynamically:</p><pre><code class=language-csharp>[EventSource(Name = &quot;MyApplication&quot;)]
public class MyApplicationEventSource : EventSource
{
    public static MyApplicationEventSource Instance = new MyApplicationEventSource();
    private readonly ConcurrentDictionary&lt;string, EventCounter&gt; _dynamicCounters = new ConcurrentDictionary&lt;string, EventCounter&gt;();

    private MyApplicationEventSource() {}

    public void RecordMetric(string name, float value)
    {
        if (string.IsNullOrWhiteSpace(name)) return;

        var counter = _dynamicCounters.GetOrAdd(name, key =&gt; new EventCounter(key, this));
        counter.WriteMetric(value);
    }
}
</code></pre><p>In order to initialize a new EventCounter instance, we need to give a name and the EventSource that it should be associated with. Whilst this is okay for simple EventCounters, we often need to do more with our applications, such as tracking the start/stopping of certain events, or tracking activities using PerfView. To do this, we can leverage more of the EventSource&rsquo;s infrastructure.</p><h3 id=using-eventcounters-and-eventsource-events>Using EventCounters And EventSource Events</h3><p>Let&rsquo;s breakdown the following example, which I&rsquo;ve taken from my <a href=https://github.com/Im5tu/OpenMessage/blob/dev/src/OpenMessage/OpenMessageEventSource.cs>OpenMessage project</a>:</p><pre><code class=language-csharp>[EventSource(Name = &quot;OpenMessage&quot;)]
internal class OpenMessageEventSource : EventSource
{
    internal static readonly OpenMessageEventSource Instance = new OpenMessageEventSource();

    private long _inflightMessages = 0;
    private long _processedCount = 0;
    private IncrementingPollingCounter _inflightMessagesCounter;
    private EventCounter _messageDurationCounter;
    private IncrementingPollingCounter _processedCountCounter;

    private OpenMessageEventSource() { }

    [NonEvent]
    public ValueStopwatch? ProcessMessageStart()
    {
        if (!IsEnabled()) return null;

        MessageStart();

        return ValueStopwatch.StartNew();
    }

    [Event(1, Level = EventLevel.Informational, Message = &quot;Consumed Message&quot;)]
    private void MessageStart()
    {
        Interlocked.Increment(ref _inflightMessages);
        Interlocked.Increment(ref _processedCount);
    }

    [NonEvent]
    public void ProcessMessageStop(ValueStopwatch stopwatch)
    {
        if (!IsEnabled()) return;

        MessageStop(stopwatch.IsActive ? stopwatch.GetElapsedTime().TotalMilliseconds : 0.0);
    }

    [Event(2, Level = EventLevel.Informational, Message = &quot;Message Completed&quot;)]
    private void MessageStop(double duration)
    {
        Interlocked.Decrement(ref _inflightMessages);
        _messageDurationCounter.WriteMetric(duration);
    }

    protected override void OnEventCommand(EventCommandEventArgs command)
    {
        if (command.Command == EventCommand.Enable)
        {
            _inflightMessagesCounter ??= new IncrementingPollingCounter(&quot;inflight-messages&quot;, this, () =&gt; _inflightMessages)
            {
                DisplayName = &quot;Inflight Messages&quot;,
                DisplayUnits = &quot;Messages&quot;
            };
            _messageDurationCounter ??= new EventCounter(&quot;message-duration&quot;, this)
            {
                DisplayName = &quot;Average Message Duration&quot;,
                DisplayUnits = &quot;ms&quot;
            };
            _processedCountCounter ??= new IncrementingPollingCounter(&quot;processed-count&quot;, this, () =&gt; _processedCount)
            {
                DisplayName = &quot;Messages Processed&quot;,
                DisplayRateTimeScale = TimeSpan.FromSeconds(1)
            };
        }
    }

    // ... code omitted for brevity
}
</code></pre><p>The example above is designed to track the number of messages processed by our system, and how long on average they took to process. The event source is also designed to be lazily initialized, so we only track information when the EventSource is enabled. Let&rsquo;s take a look at how we&rsquo;ve accomplished this by looking at <code>OnEventCommand</code>:</p><pre><code class=language-csharp>protected override void OnEventCommand(EventCommandEventArgs command)
{
    if (command.Command == EventCommand.Enable)
    {
        _inflightMessagesCounter ??= new IncrementingPollingCounter(&quot;inflight-messages&quot;, this, () =&gt; _inflightMessages)
        {
            DisplayName = &quot;Inflight Messages&quot;,
            DisplayUnits = &quot;Messages&quot;
        };
        _messageDurationCounter ??= new EventCounter(&quot;message-duration&quot;, this)
        {
            DisplayName = &quot;Average Message Duration&quot;,
            DisplayUnits = &quot;ms&quot;
        };
        _processedCountCounter ??= new IncrementingPollingCounter(&quot;processed-count&quot;, this, () =&gt; _processedCount)
        {
            DisplayName = &quot;Messages Processed&quot;,
            DisplayRateTimeScale = TimeSpan.FromSeconds(1)
        };
    }
}
</code></pre><p>This is where we register the event counters that we are interested in tracking. EventSource&rsquo;s can receive commands from external sources, so that they can enable the EventCounter API etc. We can receive this message from applications multiple times, so it&rsquo;s important to to make sure that we defensively programme. In the sample above, I use the new null-assignment expression to ensure that only when the field is null, do we perform the expression on the right hand side - which in our case is creating the counters.</p><p>There are four available types of counters available for us to use, which I will cover later on:</p><ul><li>EventCounter</li><li>IncrementingEventCounter</li><li>PollingCounter</li><li>IncrementingPollingCounter</li></ul><p>Next, we need to look how we can actually record the metrics. In order to do this, I&rsquo;ve combined it with using EventSource Event&rsquo;s so that I can also get the information that I want inside of other tools like PerfView should I want to:</p><pre><code class=language-csharp>[NonEvent]
public ValueStopwatch? ProcessMessageStart()
{
    if (!IsEnabled()) return null;

    MessageStart();

    return ValueStopwatch.StartNew();
}

[Event(1, Level = EventLevel.Informational, Message = &quot;Consumed Message&quot;)]
private void MessageStart()
{
    Interlocked.Increment(ref _inflightMessages);
    Interlocked.Increment(ref _processedCount);
}

[NonEvent]
public void ProcessMessageStop(ValueStopwatch stopwatch)
{
    if (!IsEnabled()) return;

    MessageStop(stopwatch.IsActive ? stopwatch.GetElapsedTime().TotalMilliseconds : 0.0);
}

[Event(2, Level = EventLevel.Informational, Message = &quot;Message Completed&quot;)]
private void MessageStop(double duration)
{
    Interlocked.Decrement(ref _inflightMessages);
    _messageDurationCounter.WriteMetric(duration);
}
</code></pre><p>We have two operations that we are really interested in Start & Stop. In the example above, each of the operations is split out into a <code>[NonEvent]</code> and a corresponding <code>[Event]</code>. The <code>[Event]</code> is what the EventSource system uses to write the events to the underlying stream so that it can be picked up by tools such as PerfView. The entry point is always the <code>[NonEvent]</code> so that we can check to see if anyone is listening to the EventSource before we do anything, this helps ensure that it does not emit the Event unnecessarily. This is the same pattern that is used throughout the .Net Code base from what I can tell.</p><p>For the <code>[Event]</code>'s, you will notice that the Start/Stop is EventId 1/2 respectively and the also end with Start/Stop. This allows some magic to happen such as automatically figuring out the duration inside of PerfView. For more information on some of the magic that occurs, I strongly recommend reading <a href=https://blogs.msdn.microsoft.com/vancem/2015/09/14/exploring-eventsource-activity-correlation-and-causation-features/>Vance Morrison&rsquo;s Excellent Blog Post</a> instead of me duplicating the knowledge here.</p><p>Once you have your EventSource configured, and you know which metrics you wish to track, then all that&rsquo;s left is to start recording your metrics (eg: <code>OpenMessageEventSource.ProcessMessageStart()</code>) and the runtime will take care of the rest.</p><h3 id=other-eventsource-examples>Other EventSource Examples</h3><p>For some inspiration of how to configure your EventSource&rsquo;s, here are a few examples from Microsoft:</p><ul><li><a href=https://github.com/aspnet/AspNetCore/blob/master/src/Hosting/Hosting/src/Internal/HostingEventSource.cs>HostingEventSource</a>: Used to track the current number of requests including: failed/total/requests per second.</li><li><a href=https://github.com/aspnet/AspNetCore/blob/master/src/Servers/Kestrel/Core/src/Internal/Infrastructure/KestrelEventSource.cs>KestrelEventSource</a>: Used to track details of connections to the Kestrel WebServer - including when connections and requests Start/Stop.</li><li><a href=https://github.com/aspnet/AspNetCore/blob/master/src/Middleware/ConcurrencyLimiter/src/ConcurrencyLimiterEventSource.cs>ConcurrencyLimiterEventSource</a>: Used to track the number of queued requests and the duration in the queue.</li></ul><h2 id=types-of-diagnosticcounters>Types of DiagnosticCounters</h2><p>The <code>DiagnosticCounter</code> class is the abstract base class that all of the event counters types inherit from. Currently, there are four implementations registered in the <a href=https://source.dot.net/#Microsoft.Diagnostics.Tracing.EventSource/DiagnosticCounter.cs,28677f9e15895cc9,references>source</a>: <code>EventCounter</code>, <code>IncrementingEventCounter</code>, <code>PollingCounter</code> and <code>IncrementingPollingCounter</code>. Although abstract, we can&rsquo;t really inherit from <code>DiagnosticCounter</code> as the internal components that we need, which are described below, are protected from external use. The four implementations that I mentioned, appear to cover pretty much every use case that I can think of anyway.</p><h3 id=eventcounter>EventCounter</h3><p>This type of event counter is typically used for tracking latency of requests to external parties due to the aggregated stats that this type provides. An EventCounter instance tracks the following about the metrics that it&rsquo;s recorded:</p><table><thead><tr><th>Name</th><th>Type</th><th>Notes</th></tr></thead><tbody><tr><td>Name</td><td>string</td><td></td></tr><tr><td>DisplayName</td><td>string</td><td></td></tr><tr><td>Mean</td><td>double</td><td>The average of all values recorded</td></tr><tr><td>StandardDeviation</td><td>double</td><td></td></tr><tr><td>Count</td><td>int</td><td>How many metric entries were recorded in this iteration</td></tr><tr><td>Min</td><td>double</td><td></td></tr><tr><td>Max</td><td>double</td><td></td></tr><tr><td>IntervalSec</td><td>float</td><td></td></tr><tr><td>CounterType</td><td>string</td><td>Always &ldquo;Mean&rdquo;</td></tr><tr><td>Metadata</td><td>string</td><td>Any associated metadata for this specific counter</td></tr><tr><td>DisplayUnits</td><td>string</td><td></td></tr><tr><td>Series</td><td>string</td><td>Format is: $"IntervalSec={IntervalSec}&rdquo;</td></tr></tbody></table><p>In order to write data, you need to call <code>&lt;counter>.WriteMetric(value)</code>.</p><h3 id=incrementingeventcounter>IncrementingEventCounter</h3><p>An IncrementingEventCounter is typically used to track ever increasing numbers such as the total number of requests. Unlike it&rsquo;s namesake, EventCounter, this class does not provide any statistics about the data. In other words, it is a pure counter, so only the following information is tracked:</p><table><thead><tr><th>Name</th><th>Type</th><th>Notes</th></tr></thead><tbody><tr><td>Name</td><td>string</td><td></td></tr><tr><td>DisplayName</td><td>string</td><td></td></tr><tr><td>DisplayRateTimeScale</td><td>string</td><td>The unit of measure that the metric should be shown in, eg: per-second</td></tr><tr><td>Increment</td><td>double</td><td>The value of the this is: currentValue - previousValue</td></tr><tr><td>IntervalSec</td><td>float</td><td></td></tr><tr><td>Metadata</td><td>string</td><td></td></tr><tr><td>Series</td><td>string</td><td>Format is: $"IntervalSec={IntervalSec}&rdquo;</td></tr><tr><td>CounterType</td><td>string</td><td>Always &ldquo;Sum&rdquo;</td></tr><tr><td>DisplayUnits</td><td>string</td><td></td></tr></tbody></table><p>In order to write data, you need to call <code>&lt;counter>.Increment(value)</code>. The <code>Increment</code> that you receive is always <code>currentValue - previousValue</code>.</p><h3 id=pollingcounter>PollingCounter</h3><p>A PollingCounter is very much like a standard EventCounter, but instead of the metric being written to it, a function is invoked which retrieves the value from your source of choice. An PollingCounter instance tracks the following about the metrics that it&rsquo;s recorded:</p><table><thead><tr><th>Name</th><th>Type</th><th>Notes</th></tr></thead><tbody><tr><td>Name</td><td>string</td><td></td></tr><tr><td>DisplayName</td><td>string</td><td></td></tr><tr><td>Mean</td><td>double</td><td>The average of all values recorded</td></tr><tr><td>StandardDeviation</td><td>double</td><td></td></tr><tr><td>Count</td><td>int</td><td>How many metric entries were recorded in this iteration</td></tr><tr><td>Min</td><td>double</td><td></td></tr><tr><td>Max</td><td>double</td><td></td></tr><tr><td>IntervalSec</td><td>float</td><td></td></tr><tr><td>CounterType</td><td>string</td><td>Always &ldquo;Mean&rdquo;</td></tr><tr><td>Metadata</td><td>string</td><td>Any associated metadata for this specific counter</td></tr><tr><td>DisplayUnits</td><td>string</td><td></td></tr><tr><td>Series</td><td>string</td><td>Format is: $"IntervalSec={IntervalSec}&rdquo;</td></tr></tbody></table><h3 id=incrementingpollingcounter>IncrementingPollingCounter</h3><p>A IncrementingPollingCounter is very much like a standard IncrementingEventCounter, but instead of the metric being written to it, a function is invoked which retrieves the value from your source of choice. An IncrementingPollingCounter instance tracks the following about the metrics that it&rsquo;s recorded:</p><table><thead><tr><th>Name</th><th>Type</th><th>Notes</th></tr></thead><tbody><tr><td>Name</td><td>string</td><td></td></tr><tr><td>DisplayName</td><td>string</td><td></td></tr><tr><td>DisplayRateTimeScale</td><td>string</td><td>The unit of measure that the metric should be shown in, eg: per-second</td></tr><tr><td>Increment</td><td>double</td><td>The value of the this is: currentValue - previousValue</td></tr><tr><td>IntervalSec</td><td>float</td><td></td></tr><tr><td>Metadata</td><td>string</td><td></td></tr><tr><td>Series</td><td>string</td><td>Format is: $"IntervalSec={IntervalSec}&rdquo;</td></tr><tr><td>CounterType</td><td>string</td><td>Always &ldquo;Sum&rdquo;</td></tr><tr><td>DisplayUnits</td><td>string</td><td></td></tr></tbody></table><h2 id=under-the-hood>Under the hood</h2><p>Now that we&rsquo;ve taken a look at how we construct the EvenSource so that we can create our application level metrics, we should also take a look at what happens under the hood so we can begin to complete the circle. Once you start creating any of the listed DiagnosticCounters in your application - the counter calls a method which ensures that the counter gets added to a <code>CounterGroup</code> associated with the specified EventSource. When a DiagnosticCounter is disposed, then it is removed from the CounterGroup and no longer tracked.</p><p>The <code>CounterGroup</code> is responsible for maintaining a thread that polls the DiagnosticCounters on the specified interval and updates their values. The thread isn&rsquo;t created until such time as an application calls <code>EnableEvents(eventSource, EventLevel.LogAlways, EventKeywords.All, new Dictionary&lt;string, string>{{"EventCounterIntervalSec", "1"}});</code> on an EventSource. Lastly, when the value of each DiagnosticCounter is updated, an event is raised against the EventSource that was passed to the counter which means that we can listen to this in the same way that we listen to other events on EventSource&rsquo;s - eg: PerfView/EventListener.</p><p>The whole EventSource system is very lightweight and designed for scalability in systems that generate millions of events - so we should not be too concerned about the performance of this. Naturally, the more that you listen to, the more impact this will have. I think it&rsquo;s safe to say, the code that we write in the listeners will likely be the slowest part of this system.</p><h2 id=listening-for-event-counters>Listening for event counters</h2><p>Lastly, in order to complete our circle, we need to be able to listen to the counters that we&rsquo;ve created in our applications. There are two common approaches that we can use: the CLI tool <code>dotnet-counters</code> or from within our applications using an <code>EventListener</code>.</p><h3 id=consuming-eventcounters-using-dotnet-counters>Consuming EventCounters using dotnet-counters</h3><p>As part of the diagnostic improvements in .Net Core 3, the .Net team introduced a new diagnostics tool called <code>dotnet-counters</code>. This is a stand-alone tool that can be installed using the following command:</p><pre><code class=language-plain>dotnet tool install dotnet-counters --global
</code></pre><p>Or updated to the latest version if you already have it installed:</p><pre><code class=language-plain>dotnet tool update dotnet-counters --global
</code></pre><p>After the tool has been installed, you can see the processes that are eligible for attaching to, using:</p><pre><code class=language-plain>dotnet-counters ps
    10416 dotnet     C:\Program Files\dotnet\dotnet.exe
    20660 dotnet     C:\Program Files\dotnet\dotnet.exe
    21172 dotnet     C:\Program Files\dotnet\dotnet.exe
</code></pre><p>Once you know the process that you want to attach to, you can start monitoring with the following command:</p><pre><code class=language-plain>dotnet-counters monitor -p 21172
</code></pre><p>If you are interested in specific EventSources, then you can supply a space separated list of EventSources like:</p><pre><code class=language-plain>dotnet-counters monitor -p 21172 System.Runtime MyEventSource
</code></pre><p>By default, when you ask to monitor an EventSource, it will capture and display all the counters for you. If no EventSources are specified then a default list is used, including: <code>System.Runtime</code>. If you only wish to track a few counters from each EventSource, then you specify them in square brackets directly after the EventSource name:</p><pre><code class=language-plain>dotnet-counters monitor -p 21172 System.Runtime[cpu-usage] MyEventSource[test]
</code></pre><p>All of the monitor commands will output something similar to the following:</p><pre><code class=language-plain>Press p to pause, r to resume, q to quit.
    Status: Running

[System.Runtime]
    CPU Usage (%)                                      0
[MyEventSource]
    test                                             335
</code></pre><p>Lastly, should you wish to control the rate that the counters are refreshed, supply the <code>--refresh-interval</code> parameter:</p><pre><code class=language-plain>dotnet-counters monitor -p 21172 --refresh-interval 5 System.Runtime[cpu-usage] MyEventSource[test]
</code></pre><h3 id=consuming-eventcounters-within-our-applications>Consuming EventCounters within our applications</h3><p>In order to enable tracing from within a .Net application you need three core parts:</p><ol><li>Class inheriting from EventListener</li><li>Detecting of EventSource&rsquo;s</li><li>Processing of Events</li></ol><h4 id=creating-our-eventlistener>Creating our EventListener</h4><p>For our new EventListener, I will create a simple background service as follows:</p><pre><code class=language-csharp>internal sealed class MetricsCollectionService : EventListener, IHostedService
{
    public Task StartAsync(CancellationToken cancellationToken)
    {
        return Task.CompletedTask;
    }

    public Task StopAsync(CancellationToken cancellationToken) =&gt; Task.CompletedTask;
}
</code></pre><p>This will live for the lifetime of the application and host the task that will detect lazily initiated EventSources, such as the OpenMessage one I showed earlier in this article.</p><h4 id=detecting-eventsources>Detecting EventSources</h4><p>In order to detect the lazily initiated EventSources, we need to periodically call the method <code>EventSource.GetSources()</code> which lists all of the currently available sources. we can do this from a simple task that lives against the service:</p><pre><code class=language-csharp>internal sealed class MetricsCollectionService : EventListener, IHostedService
{
    private List&lt;string&gt; RegisteredEventSources = new List&lt;string&gt;(); 
    private Task _newDataSourceTask;

    public Task StartAsync(CancellationToken cancellationToken)
    {
        _newDataSourceTask = Task.Run(async () =&gt;
        {
            while (true)
            {
                GetNewSources();
                await Task.Delay(1000);
            }
        });

        return Task.CompletedTask;
    }

    public Task StopAsync(CancellationToken cancellationToken) =&gt; Task.CompletedTask;

    protected override void OnEventSourceCreated(EventSource eventSource)
    {
        if (!RegisteredEventSources.Contains(eventSource.Name))
        {
            RegisteredEventSources.Add(eventSource.Name);
            EnableEvents(eventSource, EventLevel.LogAlways, EventKeywords.All, new Dictionary&lt;string, string&gt;
            {
                {&quot;EventCounterIntervalSec&quot;, &quot;1&quot;}
            });
        }
    }
    
    private void GetNewSources()
    {
        foreach (var eventSource in EventSource.GetSources())
            OnEventSourceCreated(eventSource);
    }
}
</code></pre><p>We&rsquo;ve got a list of the EventSources that we have already asked to be enabled so that we don&rsquo;t continually ask them to enable themselves. This helps guard against any slightly mis-constructed EventSources, though not strictly necessary.</p><h4 id=processing-events>Processing Events</h4><p>The last bit for us to do is to override the <code>OnEventWritten</code>:</p><pre><code class=language-csharp>protected override void OnEventWritten(EventWrittenEventArgs eventData)
{
    if (eventData.EventName != &quot;EventCounters&quot; 
            || eventData.Payload.Count &lt;= 0 
            || !(eventData.Payload[0] is IDictionary&lt;string, object&gt; data) 
            || !data.TryGetValue(&quot;CounterType&quot;, out var counterType) 
            || !data.TryGetValue(&quot;Name&quot;, out var name))
        return;
    
    var metricType = counterType.ToString();
    float metricValue = 0;

    if (&quot;Sum&quot;.Equals(metricType) &amp;&amp; data.TryGetValue(&quot;Increment&quot;, out var increment))
    {
        metricValue = Convert.ToSingle(increment);
    }
    else if (&quot;Mean&quot;.Equals(metricType) &amp;&amp; data.TryGetValue(&quot;Mean&quot;, out var mean))
    {
        metricValue = Convert.ToSingle(mean);
    }
    
    // do something with your metric here...
}
</code></pre><p>This method gets called for each EventSource that you have asked to receive the data from. It will be up to you to decide your own filtering policy. For each <code>EventWrittenEventArgs</code> that you receive, you need to double check that you have received an EventCounter before proceeding. Next, you need to check the payload that you received is indeed a <code>IDictionary&lt;string, object></code>, so that you can process the contents in a quick and efficient manner. Although in the implementations, there is a strongly typed class for the payload for each of the built in counters, it is internal so we are unable to consume it here. The last piece of the puzzle is for you to process the metric however you wish, ie: sending to DataDog.</p><p>Putting all of the above code together, we get something like the following:</p><pre><code class=language-csharp>internal sealed class MetricsCollectionService : EventListener, IHostedService
{
    private List&lt;string&gt; RegisteredEventSources = new List&lt;string&gt;(); 
    private Task _newDataSourceTask;

    public Task StartAsync(CancellationToken cancellationToken)
    {
        _newDataSourceTask = Task.Run(async () =&gt;
        {
            while (true)
            {
                GetNewSources();
                await Task.Delay(1000);
            }
        });

        return Task.CompletedTask;
    }

    public Task StopAsync(CancellationToken cancellationToken) =&gt; Task.CompletedTask;

    protected override void OnEventSourceCreated(EventSource eventSource)
    {
        if (!RegisteredEventSources.Contains(eventSource.Name))
        {
            RegisteredEventSources.Add(eventSource.Name);
            EnableEvents(eventSource, EventLevel.LogAlways, EventKeywords.All, new Dictionary&lt;string, string&gt;
            {
                {&quot;EventCounterIntervalSec&quot;, &quot;1&quot;}
            });
        }
    }

    protected override void OnEventWritten(EventWrittenEventArgs eventData)
    {
        if (eventData.EventName != &quot;EventCounters&quot; 
                || eventData.Payload.Count &lt;= 0 
                || !(eventData.Payload[0] is IDictionary&lt;string, object&gt; data) 
                || !data.TryGetValue(&quot;CounterType&quot;, out var counterType) 
                || !data.TryGetValue(&quot;Name&quot;, out var name))
            return;
        
        var metricType = counterType.ToString();
        float metricValue = 0;

        if (&quot;Sum&quot;.Equals(metricType) &amp;&amp; data.TryGetValue(&quot;Increment&quot;, out var increment))
        {
            metricValue = Convert.ToSingle(increment);
        }
        else if (&quot;Mean&quot;.Equals(metricType) &amp;&amp; data.TryGetValue(&quot;Mean&quot;, out var mean))
        {
            metricValue = Convert.ToSingle(mean);
        }
        
        // do something with your metric here...
    }

    private void GetNewSources()
    {
        foreach (var eventSource in EventSource.GetSources())
            OnEventSourceCreated(eventSource);
    }
}
</code></pre><p>Hopefully at this point, you have enough information on how to use the built in counters and creating your own metrics. Let me know on <a href=https://twitter.com/im5tu>Twitter</a> if you have any thoughts or comments on the contents of this post.</p><p>Thanks for reading, happy counting! :)</p></div></article><hr><div><p><i>If you haven't already, subscribe to my new <a href=https://bit.ly/im5tu-yt target=_blank>YouTube Channel</a>, Code With Stu. Here you'll find different tip, tricks and tutorials using some of the latest technologies, in bitesize chunks.</i></p></div><hr><div class=post-info><a name=series></a><b>More in the Diagnostics in .Net Core 3 series:</b><ol><li>Diagnostics in .Net Core 3: Event Counters <i>(This article)</i></li><li><a href=/article/2020/01/diagnostics-in-.net-core-3-using-dotnet-counters-with-docker/>Diagnostics in .Net Core 3: Using dotnet-counters with Docker</a></li><li><a href=/article/2020/06/diagnostics-in-.net-core-3-listening-to-outbound-http-requests/>Diagnostics in .Net Core 3: Listening to outbound HTTP requests</a></li><li><a href=/article/2020/06/diagnostics-in-.net-core-3-listening-to-inbound-http-requests/>Diagnostics in .Net Core 3: Listening to inbound HTTP requests</a></li><li><a href=/article/2020/06/diagnostics-in-.net-core-3-an-alternative-approach-to-using-dotnet-counters-with-docker/>Diagnostics in .Net Core 3: An alternative approach to using dotnet-counters with Docker</a></li></ol><p><a href=/article>View All Articles</a></p><hr><p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z"/><line x1="7" y1="7" x2="7" y2="7"/></svg><span class=tag><a href=https://im5tu.io/tags/aspnetcore>aspnetcore</a></span><span class=tag><a href=https://im5tu.io/tags/dotnet>dotnet</a></span><span class=tag><a href=https://im5tu.io/tags/diagnostics>diagnostics</a></span></p><p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text"><path d="M14 2H6A2 2 0 004 4v16a2 2 0 002 2h12a2 2 0 002-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/><polyline points="10 9 9 9 8 9"/></svg>2901 Words</p><p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>2020-01-05 14:00 +0000</p></div><div class=pagination><div class=pagination__title><span class=pagination__title-h></span><hr></div><div class=pagination__buttons><span class="button previous"><a href=https://im5tu.io/article/2020/01/diagnostics-in-.net-core-3-using-dotnet-counters-with-docker/><span class=button__icon>←</span>
<span class=button__text>Diagnostics in .Net Core 3: Using dotnet-counters with Docker</span></a></span>
<span class="button next"><a href=https://im5tu.io/article/2018/12/quick-tip-accessing-a-azure-devops-secret-from-within-a-scripted-step/><span class=button__text>Quick Tip: Accessing a Azure DevOps secret from within a scripted step</span>
<span class=button__icon>→</span></a></span></div></div><script src=https://utteranc.es/client.js repo=Im5tu/im5tu-hugo issue-term=url label=Comment theme=photon-dark crossorigin=anonymous async></script></main></div><footer class=footer><div class=footer__inner><div class=footer__content><span>&copy; 2021</span>
<span><a href=https://im5tu.io/>Stuart Blackler</a></span>
<span><a href=https://im5tu.io/article/index.xml target=_blank title=rss><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 20 20" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></span></div></div><div class=footer__inner><div class=footer__content><span>Powered by <a href=http://gohugo.io>Hugo</a></span>
<span>Theme made with &#10084; by <a href=https://github.com/rhazdon>Djordje Atlialp</a></span></div></div></footer></div><script type=text/javascript src=/bundle.min.dc716e9092c9820b77f96da294d0120aeeb189b5bcea9752309ebea27fd53bbe6b13cffb2aca8ecf32525647ceb7001f76091de4199ac5a3caa432c070247f5b.js integrity="sha512-3HFukJLJggt3+W2ilNASCu6xibW86pdSMJ6+on/VO75rE8/7KsqOzzJSVkfOtwAfdgkd5BmaxaPKpDLAcCR/Ww=="></script><script src=/js/site-20c12b24.js defer></script></body></html>