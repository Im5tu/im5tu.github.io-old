<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Messaging on Stuart Blackler&#39;s Blog</title>
    <link>https://im5tu.io/tags/messaging/index.xml</link>
    <description>Recent content in Messaging on Stuart Blackler&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="https://im5tu.io/tags/messaging/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>OpenMessage 2017 Roadmap</title>
      <link>https://im5tu.io/article/2017/02/openmessage-2017-roadmap/</link>
      <pubDate>Sat, 11 Feb 2017 12:15:27 +0000</pubDate>
      
      <guid>https://im5tu.io/article/2017/02/openmessage-2017-roadmap/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://github.com/im5tu/openmessage&#34;&gt;OpenMessage&lt;/a&gt; originally started out as a replacement for an internal library that was used across teams. At the time, the team I was apart of needed the latest version of dotnet core for the library where as the other team were stuck on RC1. They were also developing features for that version of the framework and a few pre-existing details that we were unhappy with (eg: the request/response implementation). With that in mind, I created a minimal wrapper for what we needed. Looking forward, I plan to dedicate a bit more time to the project and improve it.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;support-for-web-hook-scenarios&#34;&gt;Support for web hook scenarios&lt;/h2&gt;

&lt;p&gt;This is probably one of the bigger ideas that I have had in mind for the last month or so purely for the power that it could bring to applications. One of the core parts of our infrastructure was taking a web request generated by an external system and translating this into a message to be placed on Azure Service Bus. I see two main parts to this functionality:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Support for incomming web hooks&lt;/li&gt;
&lt;li&gt;Support for sending web hooks&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;For each portion, the framework will need to consider whether or not to send/receive to/from unique endpoints or an endpoint per message. Initially, this will be decided at composition, but may be extended to dynamic re-configuration at a later stage (which will need to be considered throughout the framework). I intend to use some lightweight routing to do this, probably using the routing module from ASP.Net core, at least, initialy.&lt;/p&gt;

&lt;h2 id=&#34;support-for-additional-providers&#34;&gt;Support for additional providers&lt;/h2&gt;

&lt;p&gt;The more providers that the project has, the more flexibility you can have inside of your applications. The main providers that I have in mind are as follows:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Azure Event Hubs&lt;/li&gt;
&lt;li&gt;Service Fabric Reliable Queues&lt;/li&gt;
&lt;li&gt;Rabbit MQ&lt;/li&gt;
&lt;li&gt;In Memory&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;There isn&amp;rsquo;t really too much to say about each of the above, except that the project will have support for each framework using the native providers. I did toy with the idea of building a complete AMQP library as part of this, but that seems a little overkill for the time being. I&amp;rsquo;ll see how the progression of libraries moving to dotnet core takes shape as another full library is quiet the undertaking.&lt;/p&gt;

&lt;h2 id=&#34;sample-creation-tutorial-series&#34;&gt;Sample creation/tutorial series&lt;/h2&gt;

&lt;p&gt;One of the big pieces that is missing at the moment are public samples of how to use the project in your application. This will help ease the onboarding process for new users/developers.&lt;/p&gt;

&lt;p&gt;Naturally, as part of all of this work, the dependencies will be kept up-to-date &amp;amp; bugs fixed. If there is something that you&amp;rsquo;d like to see, create an issue on &lt;a href=&#34;https://github.com/im5tu/openmessage&#34;&gt;github&lt;/a&gt; or &lt;a href=&#34;https://twitter.com/im5tu&#34;&gt;tweet me&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Happy Messaging!&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>OpenMessage 1.1 Released</title>
      <link>https://im5tu.io/article/2017/02/openmessage-1.1-released/</link>
      <pubDate>Sun, 05 Feb 2017 15:31:54 +0000</pubDate>
      
      <guid>https://im5tu.io/article/2017/02/openmessage-1.1-released/</guid>
      <description>&lt;p&gt;Just a quick update to say that the Azure provider for &lt;a href=&#34;https://github.com/Im5tu/OpenMessage&#34;&gt;OpenMessage&lt;/a&gt; has been released. This update fixes an issue with scheduling messages on topics.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;As part of this update, the entire solution has been converted to the new (old) csproj system as part of Visual Studio 2017. Over the next few days i&amp;rsquo;ll be posting the roadmap for the project and where I plan to take it next. Feedback and ideas are welcome.&lt;/p&gt;

&lt;p&gt;If you experience any problems, let me know.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Message Queue Fundementals: MSMQ</title>
      <link>https://im5tu.io/article/2014/09/message-queue-fundementals-msmq/</link>
      <pubDate>Sun, 28 Sep 2014 18:35:57 +0000</pubDate>
      
      <guid>https://im5tu.io/article/2014/09/message-queue-fundementals-msmq/</guid>
      <description>&lt;p&gt;MSMQ is Microsoft&amp;rsquo;s Message Queuing service that can be used to implement both synchronous and asynchronous solutions. Typically solutions are architectured using the available C++ APIâ€™s or via the relevant COM objects. The .Net Framework exposes the System.Messaging namespace which contains all the classes that you need to work with the MSMQ API. &lt;/p&gt;

&lt;p&gt;If you would like to read the first part to the article, &lt;a href=&#34;http://sblackler.net/2014/09/07/Message-Queue-Fundementals-Introduction/&#34;&gt;click here to read about Message Queue Fundamentals&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In this article I will cover the following topics:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Types of Queues in MSMQ

&lt;ul&gt;
&lt;li&gt;Application Queues

&lt;ul&gt;
&lt;li&gt;Public/Private Queues&lt;/li&gt;
&lt;li&gt;Transactional and non-transactional Queues&lt;/li&gt;
&lt;li&gt;Sub-Queues&lt;/li&gt;
&lt;li&gt;Administration Queues&lt;/li&gt;
&lt;li&gt;Response Queues&lt;/li&gt;
&lt;li&gt;Report Queues&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;System Queues

&lt;ul&gt;
&lt;li&gt;Journal Queues&lt;/li&gt;
&lt;li&gt;Internal Private Queues&lt;/li&gt;
&lt;li&gt;Dead-letter Queues&lt;/li&gt;
&lt;li&gt;Connector Queues&lt;/li&gt;
&lt;li&gt;Outgoing Queues&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Creating an MSMQ Message Queue&lt;/li&gt;
&lt;li&gt;Accessing an MSMQ Message Queue&lt;/li&gt;
&lt;li&gt;Sending a message to a MSMQ Message Queue

&lt;ul&gt;
&lt;li&gt;Sending a message to a MSMQ Message Queue using transactions&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Retrieving a message from a MSMQ Message Queue

&lt;ul&gt;
&lt;li&gt;Retrieving a message from a MSMQ Message Queue using transactions&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;Before you begin, you need to have MSMQ installed on your machine, please do this by following &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/aa967729(v=vs.110).aspx&#34;&gt;these instructions&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&#34;types-of-queues-in-msmq&#34;&gt;Types of Queues in MSMQ&lt;/h2&gt;

&lt;p&gt;This section describes the available queue types within MSMQ. Although I will not cover the consumption of all the available types of queue, I will briefly describe the following type of queue:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Application Queues

&lt;ul&gt;
&lt;li&gt;Public/Private Queues&lt;/li&gt;
&lt;li&gt;Transactional and non-transactional Queues&lt;/li&gt;
&lt;li&gt;Sub-Queues&lt;/li&gt;
&lt;li&gt;Administration Queues&lt;/li&gt;
&lt;li&gt;Response Queues&lt;/li&gt;
&lt;li&gt;Report Queues&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;System Queues

&lt;ul&gt;
&lt;li&gt;Journal Queues&lt;/li&gt;
&lt;li&gt;Internal Private Queues&lt;/li&gt;
&lt;li&gt;Dead-letter Queues&lt;/li&gt;
&lt;li&gt;Connector Queues&lt;/li&gt;
&lt;li&gt;Outgoing Queues&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The quintessential difference between application and system queues is the ability to address messages to the queue. With application queues you can have, essentially, read/write capabilities, whereas you can only read messages from a system queue.&lt;/p&gt;

&lt;h3 id=&#34;administration-queues&#34;&gt;Administration Queues&lt;/h3&gt;

&lt;h4 id=&#34;private-vs-public-queues&#34;&gt;Private vs Public Queues&lt;/h4&gt;

&lt;p&gt;Deciding between a public and private queue depends on the requirements of the application and the infrastructure available. Public queues use Active Directory Domain Services to replicate the queue through the domain forest, providing reliability. They are both persistent and available to other applications. In contrast, private queues are only displayed on the local computer that contains them. Because private queues involve no replication, they are quicker to create, have lower latency and has no replication overhead as they are not distributed through a domain forest.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;For further on the permissions required for a public queue, please see &lt;a href=&#34;http://technet.microsoft.com/en-us/library/cc772532.aspx&#34;&gt;this Technet article&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;

&lt;h4 id=&#34;transactional-vs-non-transactional-queues&#34;&gt;Transactional vs Non-Transactional Queues&lt;/h4&gt;

&lt;p&gt;As the name suggests, a transactional queue that only contains transactional messages. That is, when a message is written to/read from the queue the server/client must confirm the receipt of the message before the message can be removed from/added to the message queue. In contrast, a non-transactional queue each message is sent as a single operation (regardless of how many destinations the message is sent to), so there are no guarantees that messages will reach their destination. This is similar to TCP vs UDP. TCP (Transactional) guarantees message delivery where as UDP (Non-transactional) does not.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;For more information on transactional and non-transactional messaging, please see &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/ms704006(v=vs.85).aspx&#34;&gt;this MSDN article&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;

&lt;h4 id=&#34;sub-queues&#34;&gt;Sub-Queues&lt;/h4&gt;

&lt;p&gt;Sub-Queues are useful for a variety of scenarios including work order processing and poison message handling. Work order processing is the process in which line items are ordered in a more efficient manner for processing. Poison message handling involves dealing with messages that have exceeded the send timeout; hit the retry limit; or any application specific error such as a transaction timeout. For a more detailed explanation of poison messages, I would suggest reading the &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/ms789028(v=vs.110).aspx&#34;&gt;Poison Message Handling article on MSDN&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Unlike normal queues, the act of passing a message to a sub-queue invokes the creation of the queue if it does not already exist. If the sub-queue exists, the message is passed into the queue as normal. Furthermore, when the queue is empty and there are no open handles to the sub-queue, MSMQ removes the queue on your behalf. Apart from these main differences, sub-queues share the same properties as their parent queue, eg:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Quota&lt;/li&gt;
&lt;li&gt;Access Control List (ACL)&lt;/li&gt;
&lt;li&gt;Transactional Type&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;administration-queues-1&#34;&gt;Administration Queues&lt;/h4&gt;

&lt;p&gt;Typically, you would not be accessing administration queues as they are application-generated for the purpose of positive/negative message acknowledgement. Although any non-transactional queue can be defined as an administration queue, I will not be covering this type of queue any further.&lt;/p&gt;

&lt;h4 id=&#34;response-queues&#34;&gt;Response Queues&lt;/h4&gt;

&lt;p&gt;Like administration queues, response queues are application generated that store application generated response messages returned by an application that is reading messages. Unlike administration queues however, any available queue can be specified as a response queue. Since MSMQ has no control over the contents of a message in a response queue, it is up to the receiving application to understand and process the message correctly.&lt;/p&gt;

&lt;h4 id=&#34;report-queues&#34;&gt;Report Queues&lt;/h4&gt;

&lt;p&gt;Each computer that has MSMQ installed can have a single report queue created on it. This is an application-generated queue that is used to store report messages that detail the route that the message took in order to reach its destination. The queue must have the following label and queue type identifier:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Label: MQReport Queue&lt;/li&gt;
&lt;li&gt;Queue type identified: &lt;code&gt;{55EE8F32-CCE9-11CF-B108-0020AFD61CE9}&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A report queue can either be created through Active Directory Users and Computers, or programmatically if the correct label and queue type identifier has been specified.&lt;/p&gt;

&lt;h3 id=&#34;system-queues&#34;&gt;System Queues&lt;/h3&gt;

&lt;h4 id=&#34;journal-queues&#34;&gt;Journal Queues&lt;/h4&gt;

&lt;p&gt;A journal queue is presented in two forms: A Queue Journal &amp;amp; A Computer Journal. A queue journal details all of the messages that have been removed from a queue. A computer journal contains copies of all the messages that are sent from a computer. Typically, you would use these queues for message diagnosis and audit purposes only.&lt;/p&gt;

&lt;h4 id=&#34;internal-private-queues&#34;&gt;Internal Private Queues&lt;/h4&gt;

&lt;p&gt;Internal queues are at the core of MSMQ. They are used as interim queues for storing and forwarding messages to a destination queue. They are not published in AD DS and are local to the current computer.&lt;/p&gt;

&lt;h4 id=&#34;dead-letter-queues&#34;&gt;Dead-Letter Queues&lt;/h4&gt;

&lt;p&gt;Dead-letter queues contain messages that cannot be delivered. MSMQ provides a transactional dead-letter queue and a non-transactional dead-letter queue. The process of storing undelivered messages on a source computer is sometimes referred to as negative source journalling. Applications can only read or delete messages from a dead letter queue. Sending to the queue is handled by the MSMQ internals.&lt;/p&gt;

&lt;h4 id=&#34;connector-queues&#34;&gt;Connector Queues&lt;/h4&gt;

&lt;p&gt;Simply put, Connector queues are used for cross-platform messaging. For a detailed guide on how this works, refer to the documentation &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/ms706915(v=vs.85).aspx&#34;&gt;on MSDN&lt;/a&gt;.&lt;/p&gt;

&lt;h4 id=&#34;outgoing-queues&#34;&gt;Outgoing Queues&lt;/h4&gt;

&lt;p&gt;Outgoing queues are local internal queues that are used to store messages sent to remote queues. Messages can be stored in outgoing queues under off-line conditions and then sent to target queues on remote computers when connectivity is restored. These queues are generated automatically and cannot be created or deleted manually.&lt;/p&gt;

&lt;h2 id=&#34;creating-an-msmq-message-queue&#34;&gt;Creating an MSMQ Message Queue&lt;/h2&gt;

&lt;p&gt;After you have installed MSMQ, you  can access the control panel for MSMQ by opening &lt;code&gt;Computer Management &amp;gt; Services and Applications &amp;gt; Message Queuing&lt;/code&gt;. From here you can see the four types of queue available within MSMQ as well as the MSMQ triggers (if you installed the triggers):&lt;/p&gt;

&lt;h2 id=&#34;accessing-an-msmq-message-queue&#34;&gt;Accessing an MSMQ Message Queue&lt;/h2&gt;

&lt;p&gt;In order to access a message queue, you need to add a reference &lt;code&gt;System.Messaging&lt;/code&gt;. This will provide you access to the &lt;code&gt;MessageQueue&lt;/code&gt; class. If you know the path, format name or label you can use &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/ch1d814t(v=vs.110).aspx&#34;&gt;the following constructor overload&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var mq = new MessageQueue(pathOrFormatOrLabel);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The path name can be in the following &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/ms706083(v=vs.85).aspx&#34;&gt;syntax&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var mq = new MessageQueue(@&amp;quot;ComputerName\QueueName&amp;quot;);
var mq = new MessageQueue(@&amp;quot;ComputerName\PRIVATE$\QueueName&amp;quot;);
var mq = new MessageQueue(@&amp;quot;.\QueueName&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The period shown in the last example is a common computer representation of the local computer.&lt;/p&gt;

&lt;p&gt;In order to reference a queue by its label, the string must start with &lt;code&gt;Label:&lt;/code&gt; followed by the name of the queue. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var mq = new MessageQueue(&amp;quot;Label:TestQueue&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Lastly, accessing a queue via its GUID requires the following format `FormatName:Modifier=GUID&amp;rdquo;, for example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var mq = new MessageQueue(&amp;quot;FormatName:Public=5A5F7535-AE9A-41d4-935C-845C2AFF7112&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Dead letter queues, computer journals and queue journals can all be monitored by using the following paths:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var mq = new MessageQueue(@&amp;quot;.\DeadLetter$&amp;quot;); // Non-transactional Dead Letter Queue
var mq = new MessageQueue(@&amp;quot;.\XactDeadLetter$&amp;quot;); // Transactional Dead Letter Queue 
var mq = new MessageQueue(@&amp;quot;.\Journal$&amp;quot;); // Computer Journal
var mq = new MessageQueue(@&amp;quot;.\TestQueue\Journal$&amp;quot;); // Queue Journal                
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;sending-a-message-to-an-msmq-message-queue&#34;&gt;Sending a message to an MSMQ Message Queue&lt;/h2&gt;

&lt;p&gt;In order to send a message to a message queue, you need to know how to access the queue as described above. Next you need to create an instance of the &lt;code&gt;MessageQueue&lt;/code&gt; class using one of the following &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/System.Messaging.MessageQueue.MessageQueue(v=vs.110).aspx&#34;&gt;MessageQueue constructors&lt;/a&gt;. The &lt;code&gt;MessageQueue&lt;/code&gt; class inherits from Component, which implements &lt;code&gt;IDisposable&lt;/code&gt;, allowing us to cleanly free the resources of the queue by using a &lt;code&gt;using&lt;/code&gt; statement:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;using(var mq = new MessageQueue(&amp;quot;.\TestQueue&amp;quot;))
{
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once the queue has been created, we should check that we can write to the queue by using the &lt;code&gt;CanWrite&lt;/code&gt; property:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;using(var mq = new MessageQueue(&amp;quot;.\TestQueue&amp;quot;))
{
    if(mq.CanWrite)
    {
    }
    else
    {
        // we cannot write to the queue
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then we can create an instance of the &lt;code&gt;Message&lt;/code&gt; class and call the &lt;code&gt;Send&lt;/code&gt; method on the message queue to send our message:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;using(var mq = new MessageQueue(&amp;quot;.\TestQueue&amp;quot;))
{
    if(mq.CanWrite)
    {
        var msg = new Message(&amp;quot;Hello world&amp;quot;);
        mq.Send(msg);           
    }
    else
    {
        // we cannot write to the queue
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;sending-a-message-to-an-msmq-message-queue-using-transactions&#34;&gt;Sending a message to an MSMQ Message Queue using transactions&lt;/h3&gt;

&lt;p&gt;Sometimes we will be required to send messages to a transactional queue. We can extend our previous example to include a check on the &lt;code&gt;Transactional&lt;/code&gt; property:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;using(var mq = new MessageQueue(&amp;quot;.\TestQueue&amp;quot;))
{
    if(mq.CanWrite)
    {
        var msg = new Message(&amp;quot;Hello world&amp;quot;);
        if(mq.Transactional)
        {
        }
        else
        {   
            mq.Send(msg);
        }                       
    }
    else
    {
        // we cannot write to the queue
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here I have branched out the original code into the else branch to compare. Next, we should construct a &lt;code&gt;MessageQueueTransaction&lt;/code&gt; object which in turn can be passed to the &lt;code&gt;Send&lt;/code&gt; method. Before we call the &lt;code&gt;Send&lt;/code&gt; method, we need to ensure that we have called the &lt;code&gt;Begin&lt;/code&gt; method on the transaction object, and &lt;code&gt;Commit&lt;/code&gt; when we have completed. This will ensure that MSMQ will use the correct transactional semantics:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;using(var mq = new MessageQueue(&amp;quot;.\TestQueue&amp;quot;))
{
    if(mq.CanWrite)
    {
        var msg = new Message(&amp;quot;Hello world&amp;quot;);
        if(mq.Transactional)
        {
            var transaction = new MessageQueueTransaction();
            transaction.Begin();
            mq.Send(msg, transaction);
            transaction.Commit();
        }
        else
        {   
            mq.Send(msg);
        }                       
    }
    else
    {
        // we cannot write to the queue
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;retrieving-a-message-from-an-msmq-message-queue&#34;&gt;Retrieving a message from an MSMQ Message Queue&lt;/h2&gt;

&lt;p&gt;In order to retrieve a message from a message queue, you need to know how to access the queue as described above. Next you need to create an instance of the &lt;code&gt;MessageQueue&lt;/code&gt; class using one of the following &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/System.Messaging.MessageQueue.MessageQueue(v=vs.110).aspx&#34;&gt;MessageQueue constructors&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;using(var mq = new MessageQueue(&amp;quot;.\TestQueue&amp;quot;))
{    
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once the queue has been created, we should check that we can read from the queue by using the &lt;code&gt;CanRead&lt;/code&gt; property:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;using(var mq = new MessageQueue(&amp;quot;.\TestQueue&amp;quot;))
{
    if(mq.CanRead)
    {
    }
    else
    {
        // we can not receive from the queue
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;From here, it is a case of calling the &lt;code&gt;Receive&lt;/code&gt; method and processing the result:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;using(var mq = new MessageQueue(&amp;quot;.\TestQueue&amp;quot;))
{
    if(mq.CanRead)
    {
        var msg = mq.Receive();
        // do something with the received message
    }
    else
    {
        // we can not receive from the queue
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;You may have to set the &lt;code&gt;Formatter&lt;/code&gt; property as shown &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/y918yfy2(v=vs.110).aspx&#34;&gt;here&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;retrieving-a-message-from-an-msmq-message-queue-using-transactions&#34;&gt;Retrieving a message from an MSMQ Message Queue using transactions&lt;/h3&gt;

&lt;p&gt;Similarly to the transactional code we used when sending a message, we can inspect the &lt;code&gt;Transactional&lt;/code&gt; property on the &lt;code&gt;MessageQueue&lt;/code&gt; before creating a &lt;code&gt;MessageQueueTransaction&lt;/code&gt; object, passing it to the &lt;code&gt;Receive&lt;/code&gt; method:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;using(var mq = new MessageQueue(&amp;quot;.\TestQueue&amp;quot;))
{
    if(mq.CanRead)
    {
        if(mq.Transactional)
        {
            var transaction = new MessageQueueTransaction();
            transaction.Begin();
            mq.Receive(transaction);
            transaction.Commit();               
        }
        else
        {
            var msg = mq.Receive();
            // do something with the received message
        }
    }
    else
    {
        // we can not receive from the queue
    }
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Message Queue Fundementals: Introduction</title>
      <link>https://im5tu.io/article/2014/09/message-queue-fundementals-introduction/</link>
      <pubDate>Sun, 07 Sep 2014 18:35:37 +0000</pubDate>
      
      <guid>https://im5tu.io/article/2014/09/message-queue-fundementals-introduction/</guid>
      <description>&lt;p&gt;Message queues are a substantial part of modern day enterprise architectures and a vital part of providing scalable solutions. They are designed for asynchronous communication between different parts of the system. They help scale individual components of a system and increase reliability with the optional addition of the persistence of messages to a storage system.&lt;/p&gt;

&lt;p&gt;In the next few articles I will be covering some of the basics of message queues followed by a couple of different implementations including &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/ms711472(v=vs.85).aspx&#34;&gt;Microsoft&amp;rsquo;s MSMQ&lt;/a&gt; and &lt;a href=&#34;http://particular.net/&#34;&gt;Particular&amp;rsquo;s&lt;/a&gt; &lt;a href=&#34;http://particular.net/nservicebus&#34;&gt;NServiceBus&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;what-is-a-message-queue-mq&#34;&gt;What is a Message Queue (MQ)?&lt;/h2&gt;

&lt;p&gt;Messages queues can be thought of as any other first-in-first-out queue. Each message queue accepts a single message one at a time and stores it until a handler is ready to process this message. If there are no message handlers ready to receive the message, it remains in the queue. Some implementations of message queues allow the configuration of features such as a priority on each message, others do not.&lt;/p&gt;

&lt;p&gt;As mentioned earlier, message queues are designed to perform asynchronous communication which they achieve in one of three principals:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Fire &amp;amp; Forget&lt;/li&gt;
&lt;li&gt;Request-Response&lt;/li&gt;
&lt;li&gt;Publish/Subscribe&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;I will also detail a variant of the Request-Response pattern called Scatter-Gather and an additional technique of the Publish/Subscribe pattern called Subscription Filters.&lt;/p&gt;

&lt;h2 id=&#34;fire-forget-messaging&#34;&gt;Fire &amp;amp; Forget Messaging&lt;/h2&gt;

&lt;p&gt;Originally a military term, the phrase fire and forget has ported well to realms of programming. Typically when two entities are communicating, one entity sends a message and the other replies (be it (a)synchronously). With fire &amp;amp; forget messaging, the entity is not interested in any reply, simply the acknowledgement of the message.&lt;/p&gt;

&lt;p&gt;The best example I can think of is notifications. Once the application server has sent the notification message to the message queue, it is free to process additional requests. When a handler is free to pick up the notification message it does and sends the message on to the relevant device via the correct medium. At any stage during, the only response is acknowledgement of receipt of the notification message. This is so that the queues do not attempt to resend the message. If an error occurs, or a time-out value expires, the message is left in the queue to be tried again, depending on the nature of the error.&lt;/p&gt;

&lt;h2 id=&#34;request-reponse-messaging&#34;&gt;Request-Reponse Messaging&lt;/h2&gt;

&lt;p&gt;In request-response, two different queues are used; one for processing requests and the other for processing the responses. Whilst sending the message to the request queue, the client often includes a reply address so that a response can be sent to the correct destination.&lt;/p&gt;

&lt;p&gt;Each client typically has its own response queue, so that it only receives responses to its own requests. This pattern of messaging allows the client to continue processing while it waits for a response from the response queue, which would have otherwise been completed via synchronous communication.&lt;/p&gt;

&lt;h3 id=&#34;scatter-gather-messaging&#34;&gt;Scatter-Gather Messaging&lt;/h3&gt;

&lt;p&gt;Often responses are required from multiple sources. This is where the Scatter-Gather pattern comes in. The Scatter-Gather pattern is a composition of the publish-subcribe pattern that we will see later and the aggregator pattern. Once a message has been published, the subscribers return the responses to a central queue to be consumed by an aggregator.&lt;/p&gt;

&lt;p&gt;The aggregator will know how many responses it should expect, either by using a pre-defined value or via header information. Once the aggregation is complete, the publisher is notified via the response message queue.&lt;/p&gt;

&lt;p&gt;In this scenario, I would typically expect to see three distinct queues:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;A publisher queue&lt;/li&gt;
&lt;li&gt;An aggregation queue&lt;/li&gt;
&lt;li&gt;A response queue&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;publish-subscribe-messaging&#34;&gt;Publish/Subscribe Messaging&lt;/h2&gt;

&lt;p&gt;The publish/subscribe pattern is not to dissimilar to the observer pattern found in C#/Java. Interested parties subscribe to a specific queue in order to receive notifications. Once a message has been sent to the queue, all parties receive a copy of the message.&lt;/p&gt;

&lt;p&gt;This pattern is good for event-driven processing, since components can be added or removed with relative ease. An example would be a users address changes. The changes need to be reflected in the database, a CRM system and a third party provider. Without this pattern, the publisher would have to know about the three different systems in order to complete the processing. Instead, the publisher only knows about the queue, and the queue about the subscribers to that queue.&lt;/p&gt;

&lt;p&gt;A natural extension of this pattern is the &lt;a href=&#34;http://msdn.microsoft.com/en-gb/data/gg577609.aspx&#34;&gt;Reactive Extensions Framework (Rx)&lt;/a&gt;. It is a library for composing asynchronous and event-based programs using observable sequences and LINQ-style query operators and has been ported to many different languages.&lt;/p&gt;

&lt;h3 id=&#34;subscription-filters&#34;&gt;Subscription Filters&lt;/h3&gt;

&lt;p&gt;Subscription filters can be applied to any queue that contains a publish-subscribe model. Upon receipt of a message, the queue is responsible for deciding which messages should be sent to each handler. This allows for greater security, because not all subscribers receive all messages, but at the cost of greater processing expense. The addition of each new subscriber will impact the throughput of the queue because the new subscriber has to be considered for every message that flows through the queue.&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>